<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced · Convex.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Convex.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../quick_tutorial/">Quick Tutorial</a></li><li><a class="toctext" href="../types/">Basic Types</a></li><li><a class="toctext" href="../operations/">Supported Operations</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../complex-domain_optimization/">Complex-domain Optimization</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../faq/">FAQ</a></li><li><a class="toctext" href="../loop/">Optimizing in a Loop</a></li><li class="current"><a class="toctext" href>Advanced</a><ul class="internal"><li><a class="toctext" href="#Dual-Variables-1">Dual Variables</a></li><li><a class="toctext" href="#Warmstarting-1">Warmstarting</a></li><li><a class="toctext" href="#Fixing-and-freeing-variables-1">Fixing and freeing variables</a></li><li><a class="toctext" href="#Using-the-tree-structure-1">Using the tree structure</a></li></ul></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../credits/">Credits</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Advanced</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/Convex.jl/blob/master/docs/src/advanced.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Advanced</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Advanced-Features-1" href="#Advanced-Features-1">Advanced Features</a></h1><h2><a class="nav-anchor" id="Dual-Variables-1" href="#Dual-Variables-1">Dual Variables</a></h2><p>Convex.jl also returns the optimal dual variables for a problem. These are stored in the <code>dual</code> field associated with each constraint.</p><pre><code class="language-julia">using Convex, SCS

x = Variable()
constraint = x &gt;= 0
p = minimize(x, constraint)
solve!(p, SCSSolver())

# Get the dual value for the constraint
p.constraints[1].dual
# or
constraint.dual</code></pre><h2><a class="nav-anchor" id="Warmstarting-1" href="#Warmstarting-1">Warmstarting</a></h2><p>If you&#39;re solving the same problem many times with different values of a parameter, Convex.jl can initialize many solvers with the solution to the previous problem, which sometimes speeds up the solution time. This is called a <strong>warm start</strong>.</p><p>To use this feature, pass the optional argument <code>warmstart=true</code> to the <code>solve!</code> method.</p><pre><code class="language-julia"># initialize data
n = 1000
y = rand(n)
x = Variable(n)

# first solve
lambda = 100
problem = minimize(sumsquares(y - x) + lambda * sumsquares(x - 10))
@time solve!(problem, SCSSolver())

# now warmstart
# if the solver takes advantage of warmstarts, 
# this run will be faster
lambda = 105
@time solve!(problem, SCSSolver(), warmstart=true)</code></pre><h2><a class="nav-anchor" id="Fixing-and-freeing-variables-1" href="#Fixing-and-freeing-variables-1">Fixing and freeing variables</a></h2><p>Convex.jl allows you to fix a variable <code>x</code> to a value by calling the <code>fix!</code> method. Fixing the variable essentially turns it into a constant. Fixed variables are sometimes also called parameters.</p><p><code>fix!(x, v)</code> fixes the variable <code>x</code> to the value <code>v</code>.</p><p><code>fix!(x)</code> fixes <code>x</code> to the value <code>x.value</code>, which might be the value obtained by solving another problem involving the variable <code>x</code>.</p><p>To allow the variable <code>x</code> to vary again, call <code>free!(x)</code>.</p><p>Fixing and freeing variables can be particularly useful as a tool for performing alternating minimization on nonconvex problems. For example, we can find an approximate solution to a nonnegative matrix factorization problem with alternating minimization as follows. We use warmstarts to speed up the solution.</p><pre><code class="language-julia"># initialize nonconvex problem
n, k = 10, 1
A = rand(n, k) * rand(k, n)
x = Variable(n, k)
y = Variable(k, n)
problem = minimize(sum_squares(A - x*y), x&gt;=0, y&gt;=0)

# initialize value of y
y.value = rand(k, n)
# we&#39;ll do 10 iterations of alternating minimization
for i=1:10 
    # first solve for x
    # with y fixed, the problem is convex
    fix!(y)
    solve!(problem, SCSSolver(), warmstart = i &gt; 1 ? true : false)
    free!(y)

    # now solve for y with x fixed at the previous solution
    fix!(x)
    solve!(problem, SCSSolver(), warmstart = true)
    free!(x)
end</code></pre><h2><a class="nav-anchor" id="Using-the-tree-structure-1" href="#Using-the-tree-structure-1">Using the tree structure</a></h2><p>A Convex problem is structured as a <em>tree</em>, with the <em>root</em> being the problem object, with branches to the objective and the set of constraints. The objective is an <code>AbstractExpr</code> which itself is a tree, with each atom being a node and having <code>children</code> which are other atoms, variables, or constants. Convex provides <code>children</code> methods from <a href="https://github.com/Keno/AbstractTrees.jl">AbstractTrees.jl</a> so that the tree-traversal functions of that package can be used with Convex.jl problems and structures. This is what allows powers the printing of problems, expressions, and constraints. This can also be used to analyze the structure of a Convex.jl problem. For example,</p><pre><code class="language-julia-repl">julia&gt; using Convex, AbstractTrees

julia&gt; x = Variable()
Variable
size: (1, 1)
sign: real
vexity: affine
id: 661…845

julia&gt; p = maximize( log(x), x &gt;= 1, x &lt;= 3 )
maximize
└─ log (concave; real)
   └─ real variable (id: 661…845)
subject to
├─ &gt;= constraint (affine)
│  ├─ real variable (id: 661…845)
│  └─ 1
└─ &lt;= constraint (affine)
   ├─ real variable (id: 661…845)
   └─ 3

current status: not yet solved

julia&gt; for leaf in AbstractTrees.Leaves(p)
           println(&quot;Here&#39;s a leaf: $(summary(leaf))&quot;)
       end
Here&#39;s a leaf: real variable (id: 661…845)
Here&#39;s a leaf: real variable (id: 661…845)
Here&#39;s a leaf: constant (constant; positive)
Here&#39;s a leaf: real variable (id: 661…845)
Here&#39;s a leaf: constant (constant; positive)</code></pre><p>We can also iterate over the problem in various orders. The following descriptions are taken from the AbstractTrees.jl docstrings, which have more information.</p><h3><a class="nav-anchor" id="PostOrderDFS-1" href="#PostOrderDFS-1">PostOrderDFS</a></h3><p>Iterator to visit the nodes of a tree, guaranteeing that children will be visited before their parents.</p><pre><code class="language-julia-repl">julia&gt; for (i, node) in enumerate(AbstractTrees.PostOrderDFS(p))
           println(&quot;Here&#39;s node $i via PostOrderDFS: $(summary(node))&quot;)
       end
Here&#39;s node 1 via PostOrderDFS: real variable (id: 661…845)
Here&#39;s node 2 via PostOrderDFS: log (concave; real)
Here&#39;s node 3 via PostOrderDFS: real variable (id: 661…845)
Here&#39;s node 4 via PostOrderDFS: constant (constant; positive)
Here&#39;s node 5 via PostOrderDFS: &gt;= constraint (affine)
Here&#39;s node 6 via PostOrderDFS: real variable (id: 661…845)
Here&#39;s node 7 via PostOrderDFS: constant (constant; positive)
Here&#39;s node 8 via PostOrderDFS: &lt;= constraint (affine)
Here&#39;s node 9 via PostOrderDFS: 2-element Array{Constraint,1}
Here&#39;s node 10 via PostOrderDFS: Problem</code></pre><h3><a class="nav-anchor" id="PreOrderDFS-1" href="#PreOrderDFS-1">PreOrderDFS</a></h3><p>Iterator to visit the nodes of a tree, guaranteeing that parents will be visited before their children.</p><pre><code class="language-julia-repl">julia&gt; for (i, node) in enumerate(AbstractTrees.PreOrderDFS(p))
           println(&quot;Here&#39;s node $i via PreOrderDFS: $(summary(node))&quot;)
       end
Here&#39;s node 1 via PreOrderDFS: Problem
Here&#39;s node 2 via PreOrderDFS: log (concave; real)
Here&#39;s node 3 via PreOrderDFS: real variable (id: 661…845)
Here&#39;s node 4 via PreOrderDFS: 2-element Array{Constraint,1}
Here&#39;s node 5 via PreOrderDFS: &gt;= constraint (affine)
Here&#39;s node 6 via PreOrderDFS: real variable (id: 661…845)
Here&#39;s node 7 via PreOrderDFS: constant (constant; positive)
Here&#39;s node 8 via PreOrderDFS: &lt;= constraint (affine)
Here&#39;s node 9 via PreOrderDFS: real variable (id: 661…845)
Here&#39;s node 10 via PreOrderDFS: constant (constant; positive)</code></pre><h3><a class="nav-anchor" id="StatelessBFS-1" href="#StatelessBFS-1">StatelessBFS</a></h3><p>Iterator to visit the nodes of a tree, guaranteeing that all nodes of a level will be visited before their children.</p><pre><code class="language-julia-repl">julia&gt; for (i, node) in enumerate(AbstractTrees.StatelessBFS(p))
           println(&quot;Here&#39;s node $i via StatelessBFS: $(summary(node))&quot;)
       end
Here&#39;s node 1 via StatelessBFS: Problem
Here&#39;s node 2 via StatelessBFS: log (concave; real)
Here&#39;s node 3 via StatelessBFS: 2-element Array{Constraint,1}
Here&#39;s node 4 via StatelessBFS: real variable (id: 661…845)
Here&#39;s node 5 via StatelessBFS: &gt;= constraint (affine)
Here&#39;s node 6 via StatelessBFS: &lt;= constraint (affine)
Here&#39;s node 7 via StatelessBFS: real variable (id: 661…845)
Here&#39;s node 8 via StatelessBFS: constant (constant; positive)
Here&#39;s node 9 via StatelessBFS: real variable (id: 661…845)
Here&#39;s node 10 via StatelessBFS: constant (constant; positive)</code></pre><footer><hr/><a class="previous" href="../loop/"><span class="direction">Previous</span><span class="title">Optimizing in a Loop</span></a><a class="next" href="../contributing/"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
