<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problem Depot · Convex.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Convex.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../quick_tutorial/">Quick Tutorial</a></li><li><a class="toctext" href="../types/">Basic Types</a></li><li><a class="toctext" href="../operations/">Supported Operations</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../complex-domain_optimization/">Complex-domain Optimization</a></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../faq/">FAQ</a></li><li><a class="toctext" href="../loop/">Optimizing in a Loop</a></li><li><a class="toctext" href="../advanced/">Advanced</a></li><li class="current"><a class="toctext" href>Problem Depot</a><ul class="internal"><li><a class="toctext" href="#How-to-write-a-ProblemDepot-problem-1">How to write a ProblemDepot problem</a></li><li><a class="toctext" href="#Benchmark-only-problems-1">Benchmark-only problems</a></li><li><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../credits/">Credits</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Problem Depot</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/Convex.jl/blob/master/docs/src/problem_depot.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Problem Depot</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Problem-Depot-1" href="#Problem-Depot-1">Problem Depot</a></h1><p>Convex.jl has a submodule, <code>ProblemDepot</code> which holds a collection of convex optimization problems. The problems are used by Convex itself to test and benchmark its code, but can also be used by solvers to test and benchmark their code.</p><p>ProblemDepot has two main methods for accessing these problems: <code>Convex.ProblemDepot.run_tests</code> and <code>Convex.ProblemDepot.benchmark_suite</code>.</p><p>For example, to test the solver SCS on all the problems of the depot except the mixed-integer problems (which it cannot handle), run</p><pre><code class="language-julia">using Convex, SCS, Test
@testset &quot;SCS&quot; begin
    Convex.ProblemDepot.run_tests(; exclude=[r&quot;mip&quot;]) do p
        solve!(p, SCSSolver(verbose=0, eps=1e-6))
    end
end</code></pre><h2><a class="nav-anchor" id="How-to-write-a-ProblemDepot-problem-1" href="#How-to-write-a-ProblemDepot-problem-1">How to write a ProblemDepot problem</a></h2><p>The problems are organized into folders in <code>src/problem_depot/problems</code>. Each is written as a function, annotated by <code>@add_problem</code>, and a name, which is used to group the problems. For example, here is a simple problem:</p><pre><code class="language-julia">@add_problem affine function affine_negate_atom(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}
    x = Variable()
    p = minimize(-x, [x &lt;= 0])
    if test
        @test vexity(p) == AffineVexity()
    end
    handle_problem!(p)
    if test
        @test p.optval ≈ 0 atol=atol rtol=rtol
        @test evaluate(-x) ≈ 0 atol=atol rtol=rtol
    end
end</code></pre><p>The <code>@add_problem</code> call adds the problem to the registry of problems in <a href="#Convex.ProblemDepot.PROBLEMS"><code>Convex.ProblemDepot.PROBLEMS</code></a>, which in turn is used by <a href="@ref"><code>run_tests</code></a> and <a href="@ref"><code>benchmark_suite</code></a>. Next, <code>affine</code> is the grouping of the problem; this problem came from one of the affine tests, and in particular is testing the negation atom. Next is the function signature:</p><pre><code class="language-julia">function affine_negate_atom(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}</code></pre><p>this should be the same for every problem, except for the name, which is a description of the problem. It should include what kind of atoms it uses (<code>affine</code> in this case), so that certain kinds of atoms can be ruled out by the <code>exclude</code> keyword to <a href="@ref"><code>run_tests</code></a> and <a href="@ref"><code>benchmark_suite</code></a>; for example, many solvers cannot solve mixed-integer problems, so <code>mip</code> is included in the name of such problems.</p><p>Then begins the body of the problem. It is setup like any other Convex.jl problem, only <code>handle_problem!</code> is called instead of <code>solve!</code>. This allows particular solvers to be used (via e.g. choosing <code>handle_problem! = p -&gt; solve!(p, solver)</code>), or for any other function of the problem (e.g. <code>handle_problem! = p -&gt; Convex.conic_problem(p)</code> which is used for benchmarking problem formulation speed.) Tests should be included and gated behind <code>if test</code> blocks, so that tests can be skipped for benchmarking, or in the case that the problem is not in fact solved during <code>handle_problem!</code>.</p><p>The fact that the problems may not be solved during <code>handle_problem!</code> brings with it a small complication: any command that assumes the problem has been solved should be behind an <code>if test</code> check. For example, in some of the problems, <code>real(x.value)</code> is used, for a variable <code>x</code>; perhaps as</p><pre><code class="language-julia">x_re = real(x.value)
if test
    @test x_re = ...
end</code></pre><p>However, if the problem <code>x</code> is used in has not been solved, then <code>x.value === nothing</code>, and <code>real(nothing)</code> throws an error. So instead, this should be rewritten as</p><pre><code class="language-julia">if test
    x_re = real(x.value)
    @test x_re = ...
end</code></pre><h2><a class="nav-anchor" id="Benchmark-only-problems-1" href="#Benchmark-only-problems-1">Benchmark-only problems</a></h2><p>To add problems for benchmarking without tests, place problems in <code>src/problem_depot/problems/benchmark</code>, and include <code>benchmark</code> in the name. These problems will be automatically skipped during <code>run_tests</code> calls. For example, to benchmark the time it takes to add an SDP constraint, we have the problem</p><pre><code class="language-julia">@add_problem constraints_benchmark function sdp_constraint(handle_problem!, args...)
    p = satisfy()
    x = Variable(44, 44) # 990 vectorized entries
    push!(p.constraints, x ⪰ 0)
    handle_problem!(p)
    nothing
end</code></pre><p>However, this &quot;problem&quot; has no tests or interesting content for testing, so we skip it during testing. Note, we use <code>args...</code> in the function signature so that it may be called with the standard function signature</p><pre><code class="language-julia">f(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}</code></pre><h2><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Convex.ProblemDepot.run_tests" href="#Convex.ProblemDepot.run_tests"><code>Convex.ProblemDepot.run_tests</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run_tests(
    handle_problem!::Function;
    problems::Union{Nothing, Vector{String}, Vector{Regex}} = nothing; 
    exclude::Vector{Regex} = Regex[],
    T=Float64, atol=1e-3, rtol=0.0, 
)</code></pre><p>Run a set of tests. <code>handle_problem!</code> should be a function that takes one argument, a Convex.jl <code>Problem</code> and processes it (e.g. <code>solve!</code> the problem with a specific solver).</p><p>Use <code>exclude</code> to exclude a subset of sets; automatically excludes <code>r&quot;benchmark&quot;</code>. Optionally, pass a second argument <code>problems</code> to only allow certain problems (specified by exact names or regex). The test tolerances specified by <code>atol</code> and <code>rtol</code>. Set <code>T</code> to choose a numeric type for the problem. Currently this is only used for choosing the type parameter of the underlying MathOptInterface model, but not for the actual problem data.</p><p><strong>Examples</strong></p><pre><code class="language-julia">run_tests(exclude=[r&quot;mip&quot;]) do p
    solve!(p, SCSSolver(verbose=0))
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Convex.jl/blob/cd3012b647efa63757c8c674a055059261ce8ecc/src/problem_depot/problem_depot.jl#LL83-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Convex.ProblemDepot.benchmark_suite" href="#Convex.ProblemDepot.benchmark_suite"><code>Convex.ProblemDepot.benchmark_suite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">benchmark_suite(
    handle_problem!::Function,
    problems::Union{Nothing, Vector{String}, Vector{Regex}} = nothing; 
    exclude::Vector{Regex} = Regex[],
    test = Val(false),
    T=Float64, atol=1e-3, rtol=0.0, 
)</code></pre><p>Create a benchmark<em>suite of benchmarks. `handle</em>problem!<code>should be a function that takes one argument, a Convex.jl</code>Problem<code>and processes it (e.g.</code>solve!<code>the problem with a specific solver). Pass a second argument</code>problems` to specify run benchmarks only with certain problems (specified by exact names or regex).</p><p>Use <code>exclude</code> to exclude a subset of benchmarks. Optionally, pass a second argument <code>problems</code> to only allow certain problems (specified by exact names or regex). Set <code>test=true</code> to also check the answers, with tolerances specified by <code>atol</code> and <code>rtol</code>. Set <code>T</code> to choose a numeric type for the problem. Currently this is only used for choosing the type parameter of the underlying MathOptInterface model, but not for the actual problem data.</p><p><strong>Examples</strong></p><pre><code class="language-julia">benchmark_suite(exclude=[r&quot;mip&quot;]) do p
    solve!(p, SCSSolver(verbose=0))
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Convex.jl/blob/cd3012b647efa63757c8c674a055059261ce8ecc/src/problem_depot/problem_depot.jl#LL127-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Convex.ProblemDepot.foreach_problem" href="#Convex.ProblemDepot.foreach_problem"><code>Convex.ProblemDepot.foreach_problem</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">foreach_problem(apply::Function, [class::String],
    problems::Union{Nothing, Vector{String}, Vector{Regex}} = nothing; 
    exclude::Vector{Regex} = Regex[])</code></pre><p>Provides a convience method for iterating over problems in <a href="#Convex.ProblemDepot.PROBLEMS"><code>PROBLEMS</code></a>.  For each problem in <a href="#Convex.ProblemDepot.PROBLEMS"><code>PROBLEMS</code></a>, apply the function <code>apply</code>, which takes two arguments: the name of the function associated to the problem, and the function associated to the problem itself.</p><p>Optionally, pass a second argument <code>class</code> to only iterate over a class of problems (<code>class</code> should satsify <code>class ∈ keys(PROBLEMS)</code>), and pass third argument <code>problems</code> to only allow certain problems (specified by exact names or regex). Use the <code>exclude</code> keyword argument to exclude problems by regex.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Convex.jl/blob/cd3012b647efa63757c8c674a055059261ce8ecc/src/problem_depot/problem_depot.jl#LL44-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Convex.ProblemDepot.PROBLEMS" href="#Convex.ProblemDepot.PROBLEMS"><code>Convex.ProblemDepot.PROBLEMS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">const PROBLEMS = Dict{String, Dict{String, Function}}()</code></pre><p>A &quot;depot&quot; of Convex.jl problems, subdivided into categories. Each problem is stored as a function with the signature</p><pre><code class="language-none">f(handle_problem!, ::Val{test}, atol, rtol, ::Type{T}) where {T, test}</code></pre><p>where <code>handle_problem!</code> specifies what to do with the <code>Problem</code> instance (e.g., <code>solve!</code> it with a chosen solver), an option <code>test</code> to choose whether or not to test the values (assuming it has been solved), tolerances for the tests, and a numeric type in which the problem should be specified (currently, this is not respected and all problems are specified in <code>Float64</code> precision).</p><p>See also <a href="#Convex.ProblemDepot.run_tests"><code>run_tests</code></a> and <a href="#Convex.ProblemDepot.benchmark_suite"><code>benchmark_suite</code></a> for helpers to use these problems in testing or benchmarking.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; PROBLEMS[&quot;affine&quot;][&quot;affine_diag_atom&quot;]
affine_diag_atom (generic function with 1 method)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Convex.jl/blob/cd3012b647efa63757c8c674a055059261ce8ecc/src/problem_depot/problem_depot.jl#LL17-L41">source</a></section><footer><hr/><a class="previous" href="../advanced/"><span class="direction">Previous</span><span class="title">Advanced</span></a><a class="next" href="../contributing/"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
